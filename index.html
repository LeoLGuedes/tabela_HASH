<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Comparação de performance - Tabelas Hash (amCharts)</title>
  <!-- amCharts 5 CDN -->
  <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
  <script src="https://cdn.amcharts.com/lib/5/xy.js"></script>
  <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 16px; }
    h1 { font-size: 20px; }
    #charts { display: grid; grid-template-columns: 1fr; gap: 18px; }
    .chart-card { background: #fff; border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); padding: 12px; }
    .chart { width: 100%; height: 420px; }
    pre.instructions { background:#f7f7f7; padding:10px; border-radius:6px; }
  </style>
</head>
<body>
  <h1>Comparação de performance — Tabelas Hash</h1>
  <p>Este HTML carrega os arquivos CSV colocados em <code>src/main/resources/</code> (nomes codificados dentro do script) e gera gráficos comparativos com amCharts.</p>

  <div class="chart-card">
    <h3>Métricas Agregadas</h3>
    <div id="chart-avg" class="chart"></div>
  </div>

  <div class="chart-card">
    <h3>Tempo por operação (INSERCAO / BUSCA) — exibição detalhada</h3>
    <div id="chart-op" class="chart"></div>
  </div>

  <div class="chart-card">
    <h3>Colisões médias por configuração</h3>
    <div id="chart-collisions" class="chart"></div>
  </div>

  <h4>Instruções</h4>
  <pre class="instructions">1) Coloque todos os arquivos CSV em <code>src/main/resources/</code> (mesmo caminho do projeto).\n2) Abra este arquivo HTML no navegador (duplo-clique ou "Open File").\n3) Os gráficos irão carregar automaticamente. Caso o navegador bloqueie fetch local, rode um servidor HTTP (ex: <code>python -m http.server</code> na pasta do projeto) e abra http://localhost:8000/hash_performance_amcharts.html</pre>

<script>
// Lista de arquivos (copiada do seu diretório). Se você tiver outros nomes, adicione aqui.
const files = [
  "src/main/resources/TabelaHashArvoreBinaria_T1000_D100000_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T100_D1000_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T10_D100_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T100_D10000_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T10_D1000_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T1000_D100_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T10_D10000_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T1000_D10000_Hmod.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T100_D1000_Hmod.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T10_D100_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T100_D10000_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T10_D1000_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T1000_D100_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T10_D10000_Hmod.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T1000_D1000_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T100_D100_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T1000_D10000_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T100_D1000_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T10_D100_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T100_D10000_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T10_D1000_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T1000_D1000_Hmod.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T100_D100_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T1000_D10000_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T100_D1000_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T10_D100_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T100_D10000_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T10_D1000_Hmod.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T1000_D100_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T10_D10000_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T1000_D1000_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T100_D100_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T1000_D10000_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T100_D1000_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T10_D100_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T1000_D100_Hmod.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T10_D10000_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T1000_D1000_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T100_D100_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T1000_D10000_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T100_D1000_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T10_D100_Hmod.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T100_D10000_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T10_D1000_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T1000_D100_Hfold.csv",
  "src/main/resources/TabelaHashEncadeada_T10_D10000_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T1000_D1000_Hfold.csv",
  "src/main/resources/TabelaHashRehashing_T100_D100_Hfold.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T100_D10000_Hmod.csv",
  "src/main/resources/TabelaHashArvoreBinaria_T10_D1000_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T1000_D100_Hmod.csv",
  "src/main/resources/TabelaHashEncadeada_T10_D10000_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T1000_D1000_Hmod.csv",
  "src/main/resources/TabelaHashRehashing_T100_D100_Hmod.csv"
];

// helpers to parse filename and CSV
function parseFilename(path) {
  // expected pattern: .../TabelaHash<Algo>_T{t}_D{d}_H{hash}.csv
  const name = path.split('/').pop();
  const m = name.match(/^TabelaHash([A-Za-z]+)_T(\d+)_D(\d+)_H([A-Za-z]+)\.csv$/);
  if (!m) return { raw: name };
  return { algoritmo: m[1], tabela: +m[2], dados: +m[3], hash: m[4], raw: name };
}

function parseCSV(text) {
  // simple CSV parse for format: operacao,dado,tempo_ns,colisoes\n...
  const lines = text.trim().split(/\r?\n/).filter(l => l.trim() !== '');
  const header = lines[0].split(',').map(h=>h.trim());
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const parts = lines[i].split(',').map(p=>p.trim());
    if (parts.length < 4) continue;
    rows.push({ operacao: parts[0], dado: Number(parts[1]), tempo_ns: Number(parts[2]), colisoes: Number(parts[3]) });
  }
  return rows;
}

async function loadAll() {
  const datasets = [];
  for (const f of files) {
    try {
      const resp = await fetch(f);
      if (!resp.ok) {
        console.warn('Não conseguiu carregar', f, resp.status);
        continue;
      }
      const txt = await resp.text();
      const meta = parseFilename(f);
      const rows = parseCSV(txt);
      datasets.push({ file: f, meta, rows });
    } catch (e) {
      console.warn('Erro ao fetch', f, e);
    }
  }
  return datasets;
}

function aggregate(datasets) {
  // produce aggregates keyed by algo|tabela|dados|operacao
  const agg = {};
  for (const ds of datasets) {
    const a = ds.meta.algoritmo || 'Unknown';
    const t = ds.meta.tabela || 0;
    const d = ds.meta.dados || 0;
    const keyBase = `${a}|T${t}|D${d}|H${ds.meta.hash||''}`;
    if (!ds.rows || ds.rows.length===0) continue;
    const byOp = {};
    for (const r of ds.rows) {
      const k = r.operacao;
      if (!byOp[k]) byOp[k] = { sumTempo:0, sumCol:0, count:0 };
      byOp[k].sumTempo += r.tempo_ns;
      byOp[k].sumCol += r.colisoes;
      byOp[k].count += 1;
    }
    agg[keyBase] = { meta: ds.meta, byOp };
  }
  return agg;
}

function buildSeriesForAvg(agg) {
  // returns array of series objects: {id, algoritmo, tabela, dados, hash, avgTempo, avgCol, op}
  const series = [];
  for (const k of Object.keys(agg)){
    const ent = agg[k];
    for (const op of Object.keys(ent.byOp)){
      const v = ent.byOp[op];
      series.push({ id:k, algoritmo:ent.meta.algoritmo, tabela:ent.meta.tabela, dados:ent.meta.dados, hash:ent.meta.hash, operacao:op, avgTempo: v.sumTempo / v.count, avgCol: v.sumCol / v.count });
    }
  }
  return series;
}

// create amCharts charts
function makeAvgChart(root, data) {
  am5.ready(function() {
    root.setThemes([am5themes_Animated.new(root)]);
    const chart = root.container.children.push(am5xy.XYChart.new(root, { panX:false, panY:false }));
    const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, { categoryField: 'label', renderer: am5xy.AxisRendererX.new(root, {}) }));
    const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, { renderer: am5xy.AxisRendererY.new(root, {}) }));
    const seriesMap = {};
    // group by algoritmo+operacao
    const groups = {};
    data.forEach(d => {
      const label = `${d.algoritmo} T${d.tabela} D${d.dados} H${d.hash} (${d.operacao})`;
      groups[label] = d.avgTempo;
    });
    const chartData = Object.keys(groups).map(k=>({ label:k, value: groups[k] }));
    xAxis.data.setAll(chartData);
    const s = chart.series.push(am5xy.ColumnSeries.new(root, { name: 'Tempo médio (ns)', xAxis:xAxis, yAxis:yAxis, valueYField:'value', categoryXField:'label' }));
    s.data.setAll(chartData);
    s.columns.template.setAll({ tooltipText: '{categoryX}: {valueY.formatNumber(#,###)} ns', cornerRadiusTL:6, cornerRadiusTR:6 });
    chart.set('scrollbarX', am5.Scrollbar.new(root, { orientation: 'horizontal' }));
  });
}

function makeOpChart(root, data) {
  am5.ready(function() {
    root.setThemes([am5themes_Animated.new(root)]);
    const chart = root.container.children.push(am5xy.XYChart.new(root, { panX:false, panY:false }));
    const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, { categoryField: 'label', renderer: am5xy.AxisRendererX.new(root, {}) }));
    const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, { renderer: am5xy.AxisRendererY.new(root, {}) }));
    // create series per algorithm
    const grouped = {};
    data.forEach(d => {
      const label = `T${d.tabela} D${d.dados} H${d.hash}`;
      if (!grouped[label]) grouped[label] = {};
      const key = `${d.algoritmo} ${d.operacao}`;
      grouped[label][key] = d.avgTempo;
    });
    const labels = Object.keys(grouped);
    const keys = Array.from(new Set(data.map(d=>`${d.algoritmo} ${d.operacao}`)));
    const chartData = labels.map(l => {
      const row = { label: l };
      keys.forEach(k => row[k] = grouped[l][k] || 0);
      return row;
    });
    xAxis.data.setAll(chartData);
    keys.forEach(k => {
      const s = chart.series.push(am5xy.LineSeries.new(root, { name: k, xAxis:xAxis, yAxis:yAxis, valueYField:k, categoryXField:'label', tooltip: am5.Tooltip.new(root, {}) }));
      s.strokes.template.setAll({ strokeWidth: 2 });
      s.data.setAll(chartData);
      s.bullets.push(function(){ return am5.Bullet.new(root, { sprite: am5.Circle.new(root, { radius:5 }) }); });
    });
    chart.set('scrollbarX', am5.Scrollbar.new(root, { orientation: 'horizontal' }));
    chart.get('legend') || chart.children.push(am5.Legend.new(root, {}));
  });
}

function makeCollisionsChart(root, data) {
  am5.ready(function() {
    root.setThemes([am5themes_Animated.new(root)]);
    const chart = root.container.children.push(am5xy.XYChart.new(root, { panX:false, panY:false }));
    const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, { categoryField: 'label', renderer: am5xy.AxisRendererX.new(root, {}) }));
    const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, { renderer: am5xy.AxisRendererY.new(root, {}) }));
    const grouped = {};
    data.forEach(d => {
      const label = `${d.algoritmo} T${d.tabela} D${d.dados} H${d.hash}`;
      grouped[label] = d.avgCol;
    });
    const chartData = Object.keys(grouped).map(k=>({ label:k, value: grouped[k] }));
    xAxis.data.setAll(chartData);
    const s = chart.series.push(am5xy.ColumnSeries.new(root, { name: 'Colisões médias', xAxis:xAxis, yAxis:yAxis, valueYField:'value', categoryXField:'label' }));
    s.data.setAll(chartData);
    s.columns.template.setAll({ tooltipText: '{categoryX}: {valueY.formatNumber(#,###)}', cornerRadiusTL:6, cornerRadiusTR:6 });
    chart.set('scrollbarX', am5.Scrollbar.new(root, { orientation: 'horizontal' }));
  });
}

(async function(){
  const datasets = await loadAll();
  if (datasets.length === 0) {
    alert('Nenhum arquivo CSV foi carregado. Verifique se os arquivos estão em src/main/resources/ e se o navegador permite fetch local ou execute um servidor HTTP.');
    return;
  }
  const agg = aggregate(datasets);
  const series = buildSeriesForAvg(agg);

  // construir 3 charts
  const root1 = am5.Root.new('chart-avg');
  makeAvgChart(root1, series);
  const root2 = am5.Root.new('chart-op');
  makeOpChart(root2, series);
  const root3 = am5.Root.new('chart-collisions');
  makeCollisionsChart(root3, series);
})();
</script>
</body>
</html>